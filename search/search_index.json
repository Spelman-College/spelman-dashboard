{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spelman Dashboard Developer Docs","text":""},{"location":"#hello","title":"Hello!","text":"<p>And welcome to the Spelman Dashboard developer documentation! We're glad you're here :)</p> <p>Start by checking out our Getting Started guide.</p>"},{"location":"adding-new-aws-iam-user/","title":"Adding a New AWS IAM User","text":"<p>We manage our AWS infrastructure in Terraform. Creating a new user with console access in Terraform requires a signing key to encrypt the password that will be generated for the user. A signing key is stored in <code>infra/public.pgp</code>.</p> <p>Although you should not need to generate a new key, in case you do (e.g., if the original key becomes compromised), follow these steps:</p> <ol> <li>Start a shell in the <code>infra</code> docker container, binding the directory to <code>/infra</code>: <code>docker run -it -v $(pwd):/infra infra /bin/sh</code></li> <li>In the container's shell, generate a new key: <code>gpg --batch --passphrase '' --quick-gen-key spelmanaws@spelman.edu default default</code></li> <li>Export the public key to a file which Terraform will use: <code>gpg --export --armor | head -n -2 | tail +3 &gt; public.pgp</code>. The <code>head</code> and <code>tail</code> commands remove the header, checksum, and footer since Terraform does not expect these as part of the file.</li> <li> <p>Record the private key and store it in escrow. You can output the private key (with the necessary header, CRC checksum, and footer) by running <code>gpg --export-secret-key --armor</code></p> <p>Warning</p> <p>It is not recommended to export the private key to a file. Treat this like a password.</p> </li> </ol> <p>After merging the PR adding the new user to <code>main</code>, check the list of GitHub Actions for a run of Terraform Apply. You will see a line like</p> <pre><code>{\"@level\":\"info\",\"@message\":\"Outputs: 1\",\"@module\":\"terraform.ui\",\"@timestamp\":\"2023-07-12T00:30:14.148988Z\",\"outputs\":{\"newuser_password\":{\"sensitive\":false,\"type\":\"string\",\"value\":\"ALongBase64EncodedString\"}},\"type\":\"outputs\"}\n</code></pre> <p>The string in <code>value</code> (here, \"ALongBase64EncodedString\") is the encrypted password. We will now decrypt it to get the new user's generated password. To decrypt, follow these steps:</p> <ol> <li>Start a shell in the <code>infra</code> docker container, binding the directory to <code>/infra</code>: <code>docker run -it -v $(pwd):/infra infra /bin/sh</code></li> <li>In the container's shell, import the secret key we stored in escrow earlier. Run <code>gpg --import</code>. This will now wait for input on stdin. Copy/paste the secret key (with headers and footers) into the terminal, press Enter, then press Ctrl+D. You should see a message saying one secret key was imported.</li> <li> <p>To decrypt the string, run <code>base64 -d | gpg --decrypt; echo</code>. This will again wait for input on stdin. Copy/paste the encrypted password from the Terraform output, press Enter, then press Ctrl+D. You will see output like the following:</p> <pre><code>gpg: encrypted with cv25519 key, ID 6071A4529026850F, created 2023-07-12\n      \"spelmanaws@spelman.edu\"\nthepasswordishere\n</code></pre> <p>Store your new password securely and you're all set!</p> </li> </ol>"},{"location":"development-and-release-process/","title":"Development and Release Process","text":"<p>AWS Amplify provides a Git-based workflow for hosting serverless web apps with continous deployment. Amplify supports a multi-environment feature which leverages distinct Git branches for prod and dev. We maintain distinct dev and prod feature branches to use this feature. The release process is as follows:</p> <ol> <li><code>latest</code> contains the latest prod version. This will be renamed to a version number when the new prod version is released.</li> <li><code>main</code> is the core dev branch. Feature branches should be named descriptively. These will get merged into <code>main</code> before being cut into the prod release.</li> <li>When a new prod version is cut, <code>latest</code> will be copied to a new branch <code>v{version_number}</code>. <code>main</code> will then be merged into <code>latest</code>.</li> </ol>"},{"location":"development-and-release-process/#how-to-do-a-prod-cut-step-by-step","title":"How to do a Prod Cut Step-by-Step","text":"<ol> <li>In GitHub, create a pull request for merging <code>main</code> into <code>latest</code>.</li> <li>After it is approved, merge the change.</li> <li>On the right-hand side, click on \"Releases\".</li> <li>Click \"Draft a new release\" at the top.</li> <li>Under \"Choose a tag\", type in <code>v{version_number}</code> where <code>{version_number}</code> is the version number for this new release.</li> <li>Click the \"Generate release notes\" button to auto-generate release notes.</li> <li>Click \"Publish release\". All done!</li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install Docker.</li> </ol>"},{"location":"getting-started/#initial-setup","title":"Initial Setup","text":"<ol> <li>Clone this repository and <code>cd</code> into it.</li> <li>Set up your packages for the frontend: <code>cd frontend</code> and then <code>./run-after-changing-packages.sh</code>. This generates the <code>node_modules</code> folder and <code>package-lock.json</code> file in a Docker container and copies them locally. This is needed to run the site on your local machine.</li> <li>To verify that your image built successfully, run <code>docker image ls</code> and look for <code>spelman-dashboard-frontend</code>.</li> </ol> If you see the error ERROR: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/_ping\": dial unix /var/run/docker.sock: connect: permission denied   Then run `sudo chmod 666 /var/run/docker.sock` and retry `docker build .`."},{"location":"getting-started/#running-a-local-instance-of-the-dashboard","title":"Running a Local Instance of the Dashboard","text":"<ol> <li>From the root of the repository, <code>cd frontend</code>. Then run <code>docker compose up</code> to start a local instance of the site.</li> <li> <p>Navigate to <code>http://localhost:8080</code> in your web browser to see the site.</p> <p>Tip</p> <p>As you make changes, you don't need to reload the site. Changes should appear automatically.</p> </li> </ol>"},{"location":"getting-started/#running-a-local-instance-of-the-documentation-site","title":"Running a Local Instance of the Documentation Site","text":"<ol> <li>From the root of the repository, <code>cd docs</code>. Then run <code>docker compose up</code> to start a local instance of the site.</li> <li> <p>Navigate to <code>http://localhost:4627</code> (the port number spells \"D-O-C-S\") in your web browser to see the site.</p> <p>Tip</p> <p>As you make changes, you don't need to reload the site. Changes should appear automatically.</p> </li> </ol>"}]}